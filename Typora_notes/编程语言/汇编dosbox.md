# 汇编

[TOC]

## 环境搭建

[汇编语言学习篇2——MASM的环境搭建（win10与Ubuntu1604下的配置）【有问题，待更正】-CSDN博客](https://blog.csdn.net/weixin_42645653/article/details/120365027)

## 入门

### 工具介绍

> `masm.exe`：汇编程序，用于汇编源程序（  .asm  ），得到目标程序（  .obj  ）
> `link.exe`：连接程序，用于连接目标程序，得到可执行程序( .exe )
> `debug.exe`：调试程序，用于调试可执行程序

### debug基本操作

> `-R`命令查看、改变CPU寄存器的内容
>
> `-D`命令查看内存中的内容
>
> `-E`命令改写内存中的内容
>
> `-A`命令以汇编指令的格式在内存中写入一条机器指令 
>
> `-U`命令将内存中的机器指令翻译成汇编指令
>
> `-T`命令执行一条机器指令
>
> `-P`命令运行程序到程序正常结束
>
> `-q`命令退出

```assembly
# 查看寄存器内容
-R
# 修改寄存器AX内容
-R AX
:1234
# 查看内存内容（按顺序）
-D
# 查看特定内存地址的内容
-D 0000:0000
# 查看特定内存地址的内容（就看2行，共32bit）
-D 0000:0000 1f
# 修改内存内容
-E 0000:0000
# 写入汇编指令(CS=073f IP=0100)
-A 073f:0100
# 将机器码翻译成汇编(CS=073f IP=0100)
-U 073f:0100
```

### 汇编基本命令

### 寄存器

> 8086 有14个16位寄存器，这14个寄存器按其用途可分为
>
> (1) 通用寄存器
>
> (2) 指令指针
>
> (3) 标志寄存器
>
> (4) 段寄存器等4类。
>
> - 通用寄存器
>
>    通用寄存器有8个, 又可以分成2组,一组是数据寄存器(4个), 另一组是指针寄存器及变址寄存器(4个)
>
>   - 数据寄存器分为:
>     　　 AH&AL＝AX(accumulator)：累加寄存器， 常用于运算;在乘除等指令中指定用来存放操作数,另外, 所有的I/O指令都使用这一寄存器与外界设备传送数据
>       　　 BH&BL＝BX(base)：基址寄存器，常用于地址索引
>       　　 CH&CL＝CX(count)：计数寄存器，常用于计数； 常用于保存计算值,如在移位指令,循环(loop) 和串处理指令中用作隐含的计数器
>       　　 DH&DL＝DX(data)：数据寄存器，常用于数据传递
>       　　这4个16位的寄存器可以分为高8位: AH, BH, CH, DH.以及低八位：AL,BL,CL,DL。 这2组8位寄存器可以分别寻址，并单独使用
>
>     
>
>   - 另一组是指针寄存器和变址寄存器，包括：
>     　　 SP（Stack Pointer）：堆栈指针，与SS配合使用， 可指向目前的堆栈位置；
>         　　 BP（Base Pointer）：基址指针寄存器， 可用作SS的一个相对基址位置；
>         　　 SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针 ；
>         　　 DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。
>         　　这4个16位寄存器只能按16位进行存取操作， 主要用来形成操作数的地址， 用于堆栈操作和变址运算中计算操作数的有效地址。
>
>     
>
> - 指令指针IP(Instruction Pointer)
>   　　指令指针IP是一个16位专用寄存器， 它指向当前需要取出的指令字节， 当BIU从内存中取出一个指令字节后，IP就自动加1， 指向下一个指令字节。注意， IP指向的是指令地址的段内地址偏移量，又称偏移地址( Offset Address)或有效地址(EA，Effective Address)。
>
>   
>
> - 标志寄存器FR(Flag Register)
>   　　8086有一个18位的标志寄存器FR， 在FR中有意义的有9位，其中6位是状态位，3位是控制位。
>     　　 OF： 溢出标志位OF用于反映有符号数加减运算所得结果是否溢出。 如果运算结果超过当前运算位数所能表示的范围，则称为溢出， OF的值被置为1，否则，OF的值被清为0。
>     　　 DF：方向标志DF位用来决定在串操作指令执行时有关指针寄存器 发生调整的方向。 
>     　　 IF：中断允许标志IF位用来决定CPU是否响应CPU外部的可 屏蔽中断发出的中断请求。但不管该标志为何值， CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求， 以及CPU内部产生的中断请求。具体规定如下： 
>     　　(1)、当IF=1时， CPU可以响应CPU外部的可屏蔽中断发出的中断请求； 
>     　　(2)、当IF=0时， CPU不响应CPU外部的可屏蔽中断发出的中断请求。 
>     　　 TF：跟踪标志TF。该标志可用于程序调试。 TF标志没有专门的指令来设置或清楚。
>     　　（1）如果TF=1，则CPU处于单步执行指令的工作方式， 此时每执行完一条指令， 就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令 。
>     　　（2）如果TF=0，则处于连续工作模式。
>     　　 SF：符号标志SF用来反映运算结果的符号位， 它与运算结果的最高位相同。在微机系统中， 有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。 运算结果为正数时，SF的值为0，否则其值为1。 
>     　　 ZF： 零标志ZF用来反映运算结果是否为0。如果运算结果为0， 则其值为1，否则其值为0。在判断运算结果是否为0时， 可使用此标志位。 
>     　　 AF：下列情况下，辅助进位标志AF的值被置为1， 否则其值为0： 
>     　　(1)、在字操作时，发生低字节向高字节进位或借位时； 
>     　　(2)、在字节操作时，发生低4位向高4位进位或借位时。 
>     　　 PF：奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。 如果“1”的个数为偶数，则PF的值为1，否则其值为0。 
>     　　 CF：进位标志CF主要用来反映运算是否产生进位或借位。 如果运算结果的最高位产生了一个进位或借位，那么，其值为1， 否则其值为0。) 
>   　　 
>
> - 段寄存器(Segment Register)
>   　　为了运用所有的内存空间，8086设定了四个段寄存器， 专门用来保存段地址：
>     　　 CS（Code Segment）：代码段寄存器；
>     　　 DS（Data Segment）：数据段寄存器；
>     　　 SS（Stack Segment）：堆栈段寄存器；
>     　　 ES（Extra Segment）：附加段寄存器。
>
>   ​	当一个程序要执行时，就要决定程序代码、 数据和堆栈各要用到内存的哪些位置，通过设定段寄存器 CS，DS，SS 来指向这些起始位置。通常是将DS固定，而根据需要修改CS。 所以，程序可以在可寻址空间小于64K的情况下被写成任意大小。 所以，程序和其数据组合起来的大小，限制在DS 所指的64K内，这就是COM文件不得大于64K的原因。
>
>   　　以上是8086寄存器的整体概况, 自80386开始，PC进入32bit时代，其寻址方式，寄存器大小, 功能等都发生了变化

### mov

```assembly
# mov 寄存器,数据
mov ax,8
# mov 寄存器，寄存器
mov ax,bx
# mov 寄存器，内存单元
mov ax,[0]
# mov 内存的单元，寄存器
mov [0],ax
# mov 段寄存器，寄存器
mov ds,ax
```

### add、sub

```assembly
# add 寄存器，数据
add ax,8
# add 寄存器，寄存器
add ax,bx
# add 寄存器，内存单元
add ax,[0]
# add 内存单元，寄存器
add [0],ax

# sub 寄存器，数据
sub ax,9
# sub 寄存器，寄存器
sub ax,bx
# sub 寄存器，内存单元
sub ax,[0]
# sub 内存单元，寄存器
sub [0],ax
```



### mul

> 总结：
>
> Ax ÷ BL = AL
>
> DxAx ÷ Bx = Ax

```assembly
# mul bx，乘法案例100x10000 = (F4240)16
mov ax，64
mov bx，2710
mul bx
# 》》 AX = 4240 , DX = 000F ,乘法如果越界，商的低位放AX，高位放DX

# div bx,除法案例1000000 ÷ 10000
mov ax,4240
mov dx,F
mov bx,2710
div bx
# >> AX = 0064

# 不可整除案例 1000001 ÷ 10000 = 100 ... 1
mov ax,4241
mov dx,F
mov bx,2710
div bx
# >> AX = 0064 , DX = 0001 ，余数为1
```



### and、or

```assembly
# 与运算, debug界面不能写2进制数字 ，只能写对应的16进制
mov al，01100011B
and al，00111011B
# >>  AL = 00100011B

# 或运算
mov al，01100011B
or al，00111011B
# >>  AL = 01111011B
```

