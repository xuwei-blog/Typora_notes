# 江科大自化协C51

## 概述

[TOC]

## 常识

### 命名规则

![image-20230226221115941](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/image-20230226221115941.png)

## demo

### 独立按键

- 按键原理图

![image-20230317105323262](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303171053304.png)

- 按键的抖动

![image-20230317171629262](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303171716326.png)

- 程序

```C
#include <REGX52.H>
void Delay(unsigned int xms)		//@12.000MHz
{
	unsigned char i, j;
	while(xms--)
	{
		i = 12;
		j = 169;
		do
		{
			while (--j);
		} while (--i);
	}

}

void main()
{
	while(1)
	{
		if(P3_1 == 0)
		{
			Delay(20);	//消除抖动
			while(P3_1 == 0);
			Delay(20);
			P2_0 = ~P2_0;
		}
	}
}
```

### 数码管

- 区分共阴极和共阳极

![image-20230317180714189](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303171807245.png)

- 段码

数码管的数据位

- 原理图

![image-20230317183344110](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303171833155.png)

- 字符数组

> 数据的高位 对应 端口的高位，和大端存储没有关系
>
> 例如：
>
> ```
> //显示字符9
> abcdefg[dp] 对应为 1111 0110
> 端口最高位 - 最低位  0110 1111  ==》 6F
> ```

![image-20230321101532072](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303211015104.png)

#### 数码管程序

```C
unsigned char NixieTable[] = {0x3F,0x06,0x5B,0x4F,0x66,
							  0x6D,0x7D,0x07,0x7F,0x6F};

void Delay(unsigned int xms)		//@12.000MHz
{
	unsigned char i, j;
	while(xms--)
	{
		i = 2;
		j = 239;
		do
		{
			while (--j);
		} while (--i);
	}	
}

void Nixie(unsigned char Location,Number)
{
	switch(Location)
	{
		//38ÒëÂëÆ÷Ñ¡Ôñ
		case 1:P2_4 = 1;P2_3 = 1;P2_2 = 1;break;
		case 2:P2_4 = 1;P2_3 = 1;P2_2 = 0;break;
		case 3:P2_4 = 1;P2_3 = 0;P2_2 = 1;break;
		case 4:P2_4 = 1;P2_3 = 0;P2_2 = 0;break;
		case 5:P2_4 = 0;P2_3 = 1;P2_2 = 1;break;
		case 6:P2_4 = 0;P2_3 = 1;P2_2 = 0;break;
		case 7:P2_4 = 0;P2_3 = 0;P2_2 = 1;break;
		case 8:P2_4 = 0;P2_3 = 0;P2_2 = 0;break;		
	}
	P0 = NixieTable[Number];
    Delay(1);	//不延时会导致数码管很暗
    P0 = 0x00;	//清零
}
```

#### 数码管消影

> 显示流程：
>
> 位选 - 段选 -位选 - 段选 -位选 - 段选  .......
>
> 执行太快，会篡位
>
> 如何优化？
>
> 位选 - 段选 - 清零 - 位选 - 段选 - 清零 - 位选 - 段选 - 清零 .......

#### 数码管驱动方式

- 单片机直接扫描
  - 硬件设备简单，但会消耗大量的CPU时间
- 专用驱动芯片（例如TM1640）
  - 内部自带显存、扫描电路、单片机只需要告诉他显示什么就行

![image-20230321103229423](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303211032455.png)

### LCD1602

- 原理图

![image-20230321121951965](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303211219998.png)

- 模块化代码

![image-20230321122019956](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303211220016.png)

#### 忽略报错

![image-20230323121653385](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303231216450.png)

### 矩阵键盘

#### 扫描的概念

![image-20230321132150237](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303211321295.png)

- 原理图

![image-20230321211807119](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303212118155.png)

#### 矩阵键盘代码

```C
unsigned char MatrixKey()
{
	unsigned char KeyNumber = 0;
	//按列扫描，因为按行扫描会有接口冲突
	P1 = 0xFF;	//清零
	P1_3 = 0;	//选择第一列，再判断第几行有数据
	if(P1_7 == 0){Delay(20);while(P1_7 == 0);Delay(20);KeyNumber = 1;}
	if(P1_6 == 0){Delay(20);while(P1_6 == 0);Delay(20);KeyNumber = 5;}
	if(P1_5 == 0){Delay(20);while(P1_5 == 0);Delay(20);KeyNumber = 9;}
	if(P1_4 == 0){Delay(20);while(P1_4 == 0);Delay(20);KeyNumber = 13;}
	
	P1 = 0xFF;
	P1_2 = 0;	//选择第二列
	if(P1_7 == 0){Delay(20);while(P1_7 == 0);Delay(20);KeyNumber = 2;}
	if(P1_6 == 0){Delay(20);while(P1_6 == 0);Delay(20);KeyNumber = 6;}
	if(P1_5 == 0){Delay(20);while(P1_5 == 0);Delay(20);KeyNumber = 10;}
	if(P1_4 == 0){Delay(20);while(P1_4 == 0);Delay(20);KeyNumber = 14;}
	
	P1 = 0xFF;
	P1_1 = 0;
	if(P1_7 == 0){Delay(20);while(P1_7 == 0);Delay(20);KeyNumber = 3;}
	if(P1_6 == 0){Delay(20);while(P1_6 == 0);Delay(20);KeyNumber = 7;}
	if(P1_5 == 0){Delay(20);while(P1_5 == 0);Delay(20);KeyNumber = 11;}
	if(P1_4 == 0){Delay(20);while(P1_4 == 0);Delay(20);KeyNumber = 15;}
	
	P1 = 0xFF;
	P1_0 = 0;
	if(P1_7 == 0){Delay(20);while(P1_7 == 0);Delay(20);KeyNumber = 4;}
	if(P1_6 == 0){Delay(20);while(P1_6 == 0);Delay(20);KeyNumber = 8;}
	if(P1_5 == 0){Delay(20);while(P1_5 == 0);Delay(20);KeyNumber = 12;}
	if(P1_4 == 0){Delay(20);while(P1_4 == 0);Delay(20);KeyNumber = 16;}
	
	return KeyNumber;
}
```

#### 密码锁

```C
#include <REGX52.H>
#include "Delay.h"
#include "Nixie.h"
#include "LCD1602.h"
#include "MatrixKey.h"

unsigned char KeyNum;
unsigned int Password;
unsigned char Count;

void main()
{

	LCD_Init();
	LCD_ShowString(1,1,"password:");
 
	while(1)
	{
		KeyNum = MatrixKey();
		if(KeyNum != 0)
		{
			if(KeyNum <= 10)
			{
				if(Count < 4)
				{
					Password *= 10;				//将密码左移一位
					Password += KeyNum % 10;	//获取一位密码
					Count++;
				}
				LCD_ShowNum(2,1,Password,4);
			}
			if(KeyNum == 11) //S11按下
			{
				if(Password == 2345)
				{
					LCD_ShowString(1,10,"right");
					Password = 0;//清零
					Count = 0;
					LCD_ShowNum(2,1,Password,4);
				}
				else
				{
					LCD_ShowString(1,10,"err");
					Password = 0;//清零
					Count = 0;
					LCD_ShowNum(2,1,Password,4);
				}
			}
			if(KeyNum == 12)
			{
				Password = 0;//清零
				Count = 0;
				LCD_ShowNum(2,1,Password,4);
			}

		}
	}
}
```



### 定时器

> 简介：51单片机的定时器属于单片机的内部资源，其电路的链接和运转都在单片机内部完成
>
> 作用：
>
> 1. 用于计时系统，可以实现软件计时
> 2. 替代长时间的Delay，提高CPU运行效率和处理速度

> SYSclk：系统时钟，即晶振周期，51开发板晶振为12MHZ

#### 4中工作模式

> 最常用的模式1：16位计数器/定时器 T0、T1

#### 外接时钟

![image-20230322112016303](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303221120358.png)

#### 计数器

> 0~65535
>
> 每隔1us计数＋1
>
> 最长可定时 65535us

### 中断

#### 89C52的中断资源

> 中断源：
>
> - 外部中断0
> - 定时器0中断
> - 外部中断1
> - 定时器1中断
> - 串口中断
> - 外部中断2
> - 外部中断3

#### 中断号

![image-20230322113435794](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303221134847.png)



#### 中断初始化、中断服务程序

```C
void Timer0_Init()
{
	//TOMD 不可位寻址，只能整体赋值
	//TMOD = 0x01;	//0000 0001
	//改进TMOD赋值
	TMOD = TMOD & 0xF0;//TMOD高四位不变，低四位清零
	TMOD = TMOD | 0x01;//TMOD高四位不变，低四位置1
	
	//TCON 可位寻址，可按位赋值
	TF0 = 0;
	TR0 = 1;
	TH0 = 64535/256;
	TL0 = 64535%256+1;
	ET0 = 1;
	EA = 1;
	PT0 = 0;
}

/*定时器中断函数
void Timer0_Routine() interrupt 1
{
	static unsigned int T0Count;
	
	TH0 = 64535/256;	//保证下一次中断的初始值不变
	TL0 = 64535%256 + 1;//65536才会中断
	
	T0Count++;
	if(T0Count >= 1000)
	{
		T0Count = 0;
		
	}
}
*/
```

### 时钟demo

```C
unsigned char Sec,Min,Hour;

void main()
{
	LCD_Init();
	Timer0_Init();
	
	LCD_ShowString(1,1,"Clock");
	LCD_ShowString(2,1,"  :  :");
	
    while(1)
    {
        LCD_ShowNum(2,1,Hour,2);
		LCD_ShowNum(2,4,Min,2);
		LCD_ShowNum(2,7,Sec,2);
    }
}

void Timer0_Routine() interrupt 1
{
	static unsigned int T0Count;
	
	TH0 = 64535/256;	//保证下一次中断的初始值不变
	TL0 = 64535%256 + 1;//65536才会中断
	
	T0Count++;
	if(T0Count >= 1000)
	{
		T0Count = 0;
		Sec++;
		if(Sec >= 60)
		{
			Sec = 0;
			Min++;
			if(Min >= 60)
			{
				Min = 0;
				Hour++;
				if(Hour >= 24)
				{
					Hour = 0;
				}
			}
		}
	}
}
```

### 串口

#### 简介

![image-20230323131904780](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303231319045.png)

> 串口只能用计时器1

#### 串口硬件电路

![image-20230323132723581](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303231327697.png)

#### 电平标准

![image-20230323133010126](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303231330208.png)

#### 通讯接口

![image-20230323134000675](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303231340766.png)

#### 相关术语

![image-20230323185644384](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303231856482.png)

> SCL：时钟线

#### 51单片机的UART

![image-20230323224804657](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303232248727.png)

#### 串口参数

![image-20230323225526896](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303232255986.png)

#### 时序图

#### 串口寄存器

![image-20230323231106344](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303232311454.png)

#### 串口中断

![image-20230323231624836](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303232316945.png)

#### 串口寄存器

![image-20230323231651866](C:\Users\13192\AppData\Roaming\Typora\typora-user-images\image-20230323231651866.png)

#### 串口程序

```C
#include <REGX52.H>

void UART_Init()
{

	PCON |= 0x80;		//使能波特率倍速位SMOD
	SCON = 0x50;		//8位数据,可变波特率,接收使能
	TMOD &= 0x0F;		//清除定时器1模式位
	TMOD |= 0x20;		//设定定时器1为8位自动重装方式
	TL1 = 0xF3;		//设定定时初值			F3 = 243(D)
	TH1 = 0xF3;		//设定定时器重装值		   256 - 243 = 13us
	ET1 = 0;		//禁止定时器1中断			溢出率 1 / 13 = 0.07692MHz
	TR1 = 1;		//启动定时器1             0.0792MHz / 16 = 0.00480769MHz ≈ 4800Hz
	EA = 1;			//启动所有中断
	ES = 1;			//启动串口中断

}

void UART_SendByte(unsigned char Byte)
{
	SBUF = Byte;
	while(TI == 0);
	TI = 0;
}


/**
  * @brief 串口中断模板
  * @param
  * @retval
  */
void UART_Routine() interrupt 4
{
	if(RI == 1)		//确保是接收中断
	{

		RI = 0;
	}
}
```

### LED点阵屏

#### 显示原理

![image-20230324212803589](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303242139518.png)

#### 74HC595

- 原理图

![image-20230324223405065](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303242234116.png)

- 用于IO扩展

![image-20230324214135441](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303242141520.png)

- 一些细节

> 需要OE接低电平（OE 接 GND）



#### LED点阵原理图

![image-20230327113237293](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303271132345.png)

#### sfr、sbit

![image-20230324222940271](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303242229380.png)

#### 595程序代码

```C
#include <REGX52.H>

sbit RCK = P3^5;//RCLK
sbit SCK = P3^6;//SRCLK
sbit SER = P3^7;//SER

void _74HC595_WriteByte(unsigned char Byte)
{
	unsigned char i;
	for(i = 0; i < 8; i++)
	{
		SER = Byte & (0x80 >> i); //非0即1,8位数据分别移位
		SCK = 1; 				  //SCLK高电平,开始移位
		SCK = 0;				  //SCLK低电平，停止移位	
	}
    //移位寄存器送到缓存寄存器
	RCK = 1;	//8位准备好，一起送出去
	RCK = 0;

}

void main()
{
	SCK = 0;
	RCK = 0;
	_74HC595_WriteByte(0x00);
    while(1)
    {
        
    }
}
```

#### LED点阵显示笑脸

```C
#include <REGX52.H>
#include "Delay.h"

sbit SER = P3^4;//SER
sbit RCK = P3^5;//RCLK
sbit SCK = P3^6;//SRCLK

#define MATRIX_LED_PROT P0

/**
  * @brief 74HC595写入一个字节
  * @param 传入的字节
  * @retval
  */
void _74HC595_WriteByte(unsigned char Byte)
{
	unsigned char i;
	for(i = 0; i < 8; i++)
	{
		SER = Byte & (0x80 >> i); //非0即1,8位数据分别移位
		SCK = 1; 				  //SCLK高电平
		SCK = 0;
	}
	RCK = 1;	//8位准备好，一起送出去
	RCK = 0;

}

/**
  * @brief 74HC595显示一列数据
  * @param Column要选择的列，范围：0~7，0在最左边
  * @param Data 选择列显示的数据，高位在上，1为亮，0为灭
  * @retval
  */
void MatrixLED_ShowColumn(unsigned char Column,unsigned char Data)
{
	_74HC595_WriteByte(Data);
	MATRIX_LED_PROT = ~(0x80 >> Column);	//给0的时候选中
	Delay(1);
	MATRIX_LED_PROT = 0xFF;
}


void main()
{
	SCK = 0;
	RCK = 0;
    while(1)
    {
        MatrixLED_ShowColumn(0,0x3C);
		MatrixLED_ShowColumn(1,0x42);
		MatrixLED_ShowColumn(2,0xA9);
		MatrixLED_ShowColumn(3,0x85);
		MatrixLED_ShowColumn(4,0x85);
		MatrixLED_ShowColumn(5,0xA9);
		MatrixLED_ShowColumn(6,0x42);
		MatrixLED_ShowColumn(7,0x3C);
    }
}
```

#### 字模提取

- 基本操作

![image-20230327131003442](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303271310483.png)

- 更改参数

![image-20230327131033663](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202303271310702.png)

#### 滚动屏demo

```C
#include <REGX52.H>
#include "Delay.h"
#include "MatrixLED.h"

//code关键字：将数据放入flash，节省rom空间，缺点是不能更改
unsigned char code Animation[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xFF,0x10,0x10,0x10,0xFF,0x00,0x1C,0x2A,
	0x2A,0x2A,0x10,0x00,0x7E,0x01,0x01,0x02,
	0x00,0x7E,0x01,0x01,0x02,0x00,0x0E,0x11,
	0x11,0x11,0x0E,0x00,0x00,0x00,0x7D,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

void main()
{
	unsigned char i,Offset,Count;
	MatrixLED_Init();
	while(1)
    {
		for(i = 0; i < 8;i++)
		{
			MatrixLED_ShowColumn(i,Animation[i+Offset]);
		}
		Count++;
		if(Count>5)	//控制显示节奏，也可以用定时器控制偏移量Offset
		{
			Count=0;
			Offset++;
			if(Offset>40)	//控制循环显示
			{
				Offset = 0;
			}
		}
    }
}
```

### DS1302时钟芯片

#### 简介

![image-20230403140208099](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304031402217.png)

![image-20230403140215029](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304031402111.png)

#### 和单片机时钟的比较

- 单片机的时钟掉电不能继续计时
- 单片机时钟精度不够

#### 原理图

![image-20230403140352124](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304031403171.png)

#### 引脚和电路

![image-20230403141318688](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304031413771.png)

#### DS1302寄存器

![image-20230403142644249](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304031426310.png)

![image-20230403142206234](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304031422308.png)

- 操作方式和74HC595很像，都靠上升沿触发

#### 时序定义

- SCLK上升沿：单片机写入
- SCLK下降沿：单片机读出
- CE置1，开启
- 发一个命令字，再发数据

![image-20230403154033101](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304031540173.png)

#### BDC码转换

![image-20230403154007451](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304031540519.png)

> 十进制9：  0000 1001
>
> 十进制10：0001 0000

#### 时钟程序代码

- main函数

```C
#include <REGX52.H>
#include "LCD1602.h"
#include "DS1302.h"

unsigned char Second,Min;
void main()
{
	LCD_Init();
	LCD_ShowString(1,1,"  -  -");
	LCD_ShowString(2,1,"  :  :");
	
	DS1302_SetTime();
	
    while(1)
    {
		DS1302_ReadTime();
		LCD_ShowNum(1,1,DS1302_Time[0],2);
		LCD_ShowNum(1,4,DS1302_Time[1],2);
		LCD_ShowNum(1,7,DS1302_Time[2],2);
		LCD_ShowNum(2,1,DS1302_Time[3],2);
		LCD_ShowNum(2,4,DS1302_Time[4],2);
		LCD_ShowNum(2,7,DS1302_Time[5],2);

	}
}
```

- DS1302.c

```C
#include <REGX52.H>

sbit DS1302_SCLK = P3^6;
sbit DS1302_IO = P3^4;
sbit DS1302_CE = P3^5;

#define DS1302_SECOND 0x80
#define DS1302_MINUTE 0x82
#define DS1302_HOUR   0x84
#define DS1302_DATE   0x86
#define DS1302_MONTH  0x88
#define DS1302_DAY    0x8A
#define DS1302_YEAR   0x8C
#define DS1302_WP     0x8E


unsigned char DS1302_Time[] = {23,4,3,16,30,01,1};

void DS1302_Init()
{
	DS1302_CE = 0;
	DS1302_SCLK = 0;
}

void DS1302_WriteByte(unsigned char Command,Data)
{
	unsigned char i;
	DS1302_CE = 1;
	//DS1302_IO = Command & 0x01;	//从最低位开始，传入寄存器IO
	//DS1302_SCLK = 1;	//51单片机操作速率慢，一条操作1us，不需要延时
	//DS1302_SCLK = 0;
	for(i = 0; i < 8; i++)
	{
		DS1302_IO = Command & (0x01 << i);
		DS1302_SCLK = 1;
		DS1302_SCLK = 0;
	}
	
	for(i = 0; i < 8; i++)
	{
		DS1302_IO = Data & (0x01 << i);
		DS1302_SCLK = 1;
		DS1302_SCLK = 0;
	}
	DS1302_CE = 0;
}

unsigned char DS1302_ReadByte(unsigned char Command)
{
	unsigned char i,Data=0x00;//局部变量不会初始化
	Command |= 0x01;		//将命令字第一位改为读
	DS1302_CE = 1;
	for(i = 0; i < 8; i++)
	{
		DS1302_IO = Command & (0x01 << i);
		DS1302_SCLK = 0;	//避免直接读到第一个数据
		DS1302_SCLK = 1;
	}

	for(i = 0; i < 8; i++)
	{
		DS1302_SCLK = 1;	//重复置1，过滤掉一个周期
		DS1302_SCLK = 0;
		if(DS1302_IO){Data |= (0x01<<i);}
	}
	
	DS1302_CE = 0;
	DS1302_IO = 0;
	return Data;
}

void DS1302_SetTime()
{
	DS1302_WriteByte(DS1302_WP,0x00);//关闭写保护
	DS1302_WriteByte(DS1302_YEAR,DS1302_Time[0]/10*16+DS1302_Time[0]%10);//10进制转换为BCD
	DS1302_WriteByte(DS1302_MONTH,DS1302_Time[1]/10*16+DS1302_Time[1]%10);
	DS1302_WriteByte(DS1302_DATE,DS1302_Time[2]/10*16+DS1302_Time[2]%10);
	DS1302_WriteByte(DS1302_HOUR,DS1302_Time[3]/10*16+DS1302_Time[3]%10);
	DS1302_WriteByte(DS1302_MINUTE,DS1302_Time[4]/10*16+DS1302_Time[4]%10);
	DS1302_WriteByte(DS1302_SECOND,DS1302_Time[5]/10*16+DS1302_Time[5]%10);
	DS1302_WriteByte(DS1302_DAY,DS1302_Time[6]/10*16+DS1302_Time[6]%10);
	DS1302_WriteByte(DS1302_WP,0x80);//打开写保护
}

void DS1302_ReadTime()
{
	unsigned char Temp;
	//DS1302_Time[0] = DS1302_ReadByte(0x81);//读字节函数已经将地址改为 读地址
	Temp = DS1302_ReadByte(DS1302_YEAR);
	DS1302_Time[0] = Temp/16*10+Temp%16;
	Temp = DS1302_ReadByte(DS1302_MONTH);
	DS1302_Time[1] = Temp/16*10+Temp%16;
	Temp = DS1302_ReadByte(DS1302_DATE);
	DS1302_Time[2] = Temp/16*10+Temp%16;
	Temp = DS1302_ReadByte(DS1302_HOUR);
	DS1302_Time[3] = Temp/16*10+Temp%16;
	Temp = DS1302_ReadByte(DS1302_MINUTE);
	DS1302_Time[4] = Temp/16*10+Temp%16;
	Temp = DS1302_ReadByte(DS1302_SECOND);
	DS1302_Time[5] = Temp/16*10+Temp%16;
	Temp = DS1302_ReadByte(DS1302_DAY);
	DS1302_Time[6] = Temp/16*10+Temp%16;
}
```

- DS1302.h

```C
#ifndef __DS1302_H__
#define __DS1302_H__

extern unsigned char DS1302_Time[];

void DS1302_Init();
void DS1302_WriteByte(unsigned char Command,Data);
unsigned char DS1302_ReadByte(unsigned char Command);
void DS1302_ReadTime();
void DS1302_SetTime();

#endif
```

#### 可调时钟程序代码

- main

```C
#include <REGX52.H>
#include "LCD1602.h"
#include "DS1302.h"
#include "Delay.H"
#include "Key.h"
#include "Timer0.h"

unsigned char KeyNum,Mode,TimeSetSelect,TimeSetFlashFlag;

void TimeShow()
{
	DS1302_ReadTime();
	LCD_ShowNum(1,1,DS1302_Time[0],2);
	LCD_ShowNum(1,4,DS1302_Time[1],2);
	LCD_ShowNum(1,7,DS1302_Time[2],2);
	LCD_ShowNum(2,1,DS1302_Time[3],2);
	LCD_ShowNum(2,4,DS1302_Time[4],2);
	LCD_ShowNum(2,7,DS1302_Time[5],2);
}

void TimeSet()
{
	if(KeyNum ==2)
	{
		TimeSetSelect++;
		TimeSetSelect %= 6; //越界清零，将数据范围固定在0~5
	}
	if(KeyNum == 3)
	{
		DS1302_Time[TimeSetSelect]++;
		if(DS1302_Time[0] > 99){DS1302_Time[0] = 0;}
		if(DS1302_Time[1] > 12){DS1302_Time[1] = 1;}
		//判断大的月份
		if(DS1302_Time[1] == 1 || DS1302_Time[1] == 3 || DS1302_Time[1] ==5  ||
		   DS1302_Time[1] == 7 || DS1302_Time[1] == 8 || DS1302_Time[1] ==10 ||
		   DS1302_Time[1] ==12)
		{
			if(DS1302_Time[2] > 31){DS1302_Time[2] = 1;}
		}
		//判断小的月份
		else if(DS1302_Time[1] == 4 || DS1302_Time[1] == 6 ||
			    DS1302_Time[1] == 9 || DS1302_Time[1] == 11 )
		{
			if(DS1302_Time[2] > 30){DS1302_Time[2] = 1;}
		}
		//判断2月
		else if(DS1302_Time[1] == 2)
		{
			//判断闰年的2月
			if((DS1302_Time[0] % 4 == 0) && (DS1302_Time[0] % 100 != 0 ) || (DS1302_Time[0] % 400 == 0))
			{
				if(DS1302_Time[2] > 29){DS1302_Time[2] = 1;}
			}
			else
			{
				if(DS1302_Time[2] > 28){DS1302_Time[2] = 1;}
			}
		}
		if(DS1302_Time[3] > 23){DS1302_Time[3] = 0;}
		if(DS1302_Time[4] > 59){DS1302_Time[4] = 0;}
		if(DS1302_Time[5] > 59){DS1302_Time[5] = 0;}
	}
	if(KeyNum == 4)
	{
		DS1302_Time[TimeSetSelect]--;
		if(DS1302_Time[0] < 0){DS1302_Time[0] = 99;}	//日期数组改成有符号的，才能判断小于0
		if(DS1302_Time[1] < 1){DS1302_Time[1] = 12;}
		//判断大的月份
		if(DS1302_Time[1] == 1 || DS1302_Time[1] == 3 || DS1302_Time[1] ==5  ||
		   DS1302_Time[1] == 7 || DS1302_Time[1] == 8 || DS1302_Time[1] ==10 ||
		   DS1302_Time[1] ==12)
		{
			if(DS1302_Time[2] < 1){DS1302_Time[2] = 31;}
			if(DS1302_Time[2] > 31){DS1302_Time[2] = 1;}
		}
		//判断小的月份
		else if(DS1302_Time[1] == 4 || DS1302_Time[1] == 6 ||
			    DS1302_Time[1] == 9 || DS1302_Time[1] == 11 )
		{
			if(DS1302_Time[2] < 1){DS1302_Time[2] = 30;}
			if(DS1302_Time[2] > 30){DS1302_Time[2] = 1;}
		}
		//判断2月
		else if(DS1302_Time[1] == 2)
		{
			//判断闰年的2月
			if((DS1302_Time[0] % 4 == 0) && (DS1302_Time[0] % 100 != 0 ) || (DS1302_Time[0] % 400 == 0))
			{
				if(DS1302_Time[2] < 1){DS1302_Time[2] = 29;}
				if(DS1302_Time[2] > 29){DS1302_Time[2] = 1;}//修改月份时，可以验证日期，3月31，减月份到2月31时
			}
			else
			{
				if(DS1302_Time[2] < 1){DS1302_Time[2] = 28;}
				if(DS1302_Time[2] > 28){DS1302_Time[2] = 1;}
			}
		}
		if(DS1302_Time[3] < 0){DS1302_Time[3] = 23;}
		if(DS1302_Time[4] < 0){DS1302_Time[4] = 59;}
		if(DS1302_Time[5] < 0){DS1302_Time[5] = 59;}
	}
	//更新显示
	if(TimeSetSelect == 0 && TimeSetFlashFlag == 1){LCD_ShowString(1,1,"  ");}
	else{LCD_ShowNum(1,1,DS1302_Time[0],2);}
	
	if(TimeSetSelect == 1 && TimeSetFlashFlag == 1){LCD_ShowString(1,4,"  ");}
	else{LCD_ShowNum(1,4,DS1302_Time[1],2);}
	
	if(TimeSetSelect == 2 && TimeSetFlashFlag == 1){LCD_ShowString(1,7,"  ");}
	else{LCD_ShowNum(1,7,DS1302_Time[2],2);}

	if(TimeSetSelect == 3 && TimeSetFlashFlag == 1){LCD_ShowString(2,1,"  ");}
	else{LCD_ShowNum(2,1,DS1302_Time[3],2);}
	
	if(TimeSetSelect == 4 && TimeSetFlashFlag == 1){LCD_ShowString(2,4,"  ");}
	else{LCD_ShowNum(2,4,DS1302_Time[4],2);}
	
	if(TimeSetSelect == 5 && TimeSetFlashFlag == 1){LCD_ShowString(2,7,"  ");}
	else{LCD_ShowNum(2,7,DS1302_Time[5],2);}
}

void main()
{
	LCD_Init();
	DS1302_Init();
	Timer0_Init();
	LCD_ShowString(1,1,"  -  -");
	LCD_ShowString(2,1,"  :  :");
	DS1302_SetTime();
	
    while(1)
    {
		KeyNum = Key();
		if(KeyNum==1)	//按下按钮改变模式
		{
			if(Mode == 0){Mode = 1;TimeSetSelect = 0;}
			else if(Mode == 1){Mode = 0;DS1302_SetTime();}	//跳转的时候修改日期
		}
		switch(Mode)
		{
			case 0:TimeShow();break;
			case 1:TimeSet();break;
		}

	}
}

void Timer0_Routine() interrupt 1
{
	static unsigned int T0Count;
	
	TH0 = 64535/256;	//保证下一次中断的初始值不变
	TL0 = 64535%256 + 1;//65536才会中断
	
	T0Count++;
	if(T0Count >= 500)
	{
		T0Count = 0;
		TimeSetFlashFlag = !TimeSetFlashFlag;
	}
}
```

### 蜂鸣器

#### 简介

![image-20230404115614953](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304041156109.png)

#### 驱动方式

![image-20230404120847114](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304041208196.png)

> NPN型：给1打开
>
> PNP型：给0打开

> 芯片驱动:因为单片机的IO口不能直接驱动蜂鸣器，通过ULN2003芯片驱动

> 不能让无源蜂鸣器始终通电

> 达林顿晶体管（复合管NPN型）：2个三极管复合

![image-20230404122020273](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304041220346.png)

#### 乐谱

> 小字组，小字1组...

![image-20230404123703701](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304041237937.png)

![image-20230404123735483](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304041237553.png)

![image-20230404124111852](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304041241931.png)

> 乐谱直接写数字：大部分表示4分音谱，右边加 - ，表示2分音符，下面加 - ，表示8分音符
>
> 4分音符：大部分为500ms

![image-20230404125809257](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304041258437.png)

> #：升音符号，按左上角黑键
>
> b：降音符号

#### 乐谱如何转换成频率

![image-20230404134926376](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304041349476.png)

> 翻转IO口，翻转两次才是一个周期

![image-20230404134848486](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304041348587.png)

#### 蜂鸣器发声程序代码

- main

```C
#include <REGX52.H>
#include "Delay.h"
#include "Key.h"
#include "Nixie.h"
#include "Buzzer.h"


unsigned char KeyNum;


void main()
{
	Nixie(1,0);
    while(1)
    {
        KeyNum = Key();
		if(KeyNum)
		{
			Buzzer_Time(100);
			Nixie(1,KeyNum);
		}
    }
}
```

- Buzzer.c

```C
#include <REGX52.H>
#include "Delay.h"

sbit Buzzer = P2^5;
unsigned int i;


/**
  * @brief 蜂鸣器发声
  * @param ms 发声的时长
  * @retval 无
  */
void Buzzer_Time(unsigned int ms)
{
	for(i = 0; i < ms; i++)//Delay两次，翻转一个周期是2ms，频率是500Hz
	{
		Buzzer = !Buzzer;
		Delay(1);		//循环1次1ms，循环ms次，以500Hz响ms(ms)
	}
}
```

#### 天空之城

```C
#include <REGX52.H>
#include "Delay.h"
#include "Timer0.h"
#include "Buzzer.h"

//以16分音符为一个时间单位，4分音符为4个时间单位
#define SPEED 125

sbit Buzzer = P2^5;

//定义音符、索引
#define P0 	0
#define L1 	1
#define L1_ 2
#define L2	3
#define L2_ 4
#define L3  5
#define L4  6
#define L4_ 7
#define L5  8
#define L5_ 9
#define L6  10
#define L6_ 11
#define L7  12

#define M1 	13
#define M1_ 14
#define M2	15
#define M2_ 16
#define M3  17
#define M4  18
#define M4_ 19
#define M5  20
#define M5_ 21
#define M6  22
#define M6_ 23
#define M7  23

#define H1 	24
#define H1_ 25
#define H2	26
#define H2_ 27
#define H3  28
#define H4  29
#define H4_ 30
#define H5  31
#define H5_ 32
#define H6  33
#define H6_ 34
#define H7  35

//休止符，低音，中音，高音
unsigned int code FreqTable[] = {0,
63628,63731,63835,63928,64021,64103,64185,64260,64331,64400,64463,64524,
64580,64633,64684,64732,64777,64820,64860,64898,64934,64968,65000,65030,
65058,65085,65110,65134,65157,65178,65198,65217,65235,65252,65268,65283  };

unsigned char FreqSelect,MusicSelect;


unsigned char code Music[] = {
	//1
	P0,4,
	P0,4,
	P0,4,
	M6,2,
	M7,2,
	
	H1,4+2,
	M7,2,
	H1,4,
	H3,4,
	
	M7,4+4+4,
	M3,2,
	M3,2,
	
	//2
	M6,4+2,
	M5,2,
	M6,4,
	H1,4,
	
	M5,4+4+4,
	M3,4,
	
	M4,4+2,
	M3,2,
	M4,4,
	H1,4,
	
	//3
	M3,4+4,
	P0,2,
	H1,2,
	H1,2,
	H1,2,
	
	M7,4+2,
	M4_,2,
	M4_,4,
	M7,4,
	
	M7,4+4,
	P0,4,
	M6,2,
	M7,2,
	
	//4
	H1,4+2,
	M7,2,
	H1,4,
	H3,4,
	
	M7,4+4+4,
	M3,2,
	M3,2,
	
	M6,4+2,
	M5,2,
	M6,4,
	H1,4,
	
	//5
	M5,4+4+4,
	M2,2,
	M3,2,
	
	M4,4,
	H1,2,
	M7,2+2,
	H1,2+4,

	
	H2,2,
	H2,2,
	H3,2,
	H1,2+4+4,

	//6
	H1,2,
	M7,2,
	M6,2,
	M6,2,
	M7,4,
	M5_,4,
	
	M6,4+4+4,
	H1,2,
	H2,2,
	
	H3,4+2,
	H2,2,
	H3,4,
	H5,4,
	
	//7
	H2,4+4+4,
	M5,2,
	M5,2,
	
	H1,4+2,
	M7,2,
	H1,4,
	H3,4,
	
	H3,4+4+4+4,
	
	//8
	M6,2,
	M7,2,
	H1,4,
	H7,4,
	H2,2,
	H2,2,
	
	H1,4+2,
	M5,2+4+4,
	
	H4,4,
	H3,4,
	H2,4,
	H1,4,
	
	//9
	H3,4+4+4,
	H3,4,
	
	H6,4+4,
	H5,4,
	H5,4,
	
	H3,2,
	H2,2,
	H1,4+4,
	P0,2,
	H1,2,
	
	//10
	H2,4,
	H1,2,
	H2,2,
	H2,4,
	H5,4,
	
	H3,4+4+4,
	H3,4,
	
	H6,4+4,
	H5,4+4,
	
	//11
	H3,2,
	H2,2,
	H1,4+4,
	P0,2,
	H1,2,
	
	H2,4,
	H1,2,
	H2,2+4,
	M7,4,
	
	M6,4+4+4,
	M6,2,
	M7,2,
	
	0xFF
};

void main()
{
	Timer0_Init();
    while(1)
    {
		if(Music[MusicSelect] != 0xFF)
		{
			FreqSelect = Music[MusicSelect];
			MusicSelect++;
			Delay(SPEED*Music[MusicSelect]);
			MusicSelect++;
			//避免两个音连续，需要有抬手过程
			TR0 = 0;
			Delay(5);
			TR0 = 1;
		}
		else
		{
			TR0 = 0;
			while(1);//也可以设置循环播放
		}
    }
}


void Timer0_Routine() interrupt 1
{
	if(Music[MusicSelect] != 0)
	{
		TH0 = FreqTable[FreqSelect]/256;
		TL0 = FreqTable[FreqSelect]%256;
		Buzzer = !Buzzer;
	}
}
```

#### 小星星

> 代码可以优化，乐谱不完整

```C
#include <REGX52.H>
#include "Delay.h"
#include "Timer0.h"
#include "Buzzer.h"

#define SPEED 125
sbit Buzzer = P2^5;

//休止符，低音，中音，高音
unsigned int FreqTable[] = {0,
63628,63731,63835,63928,64021,64103,64185,64260,64331,64400,64463,64524,
64580,64633,64684,64732,64777,64820,64860,64898,64934,64968,65000,65030,
65058,65085,65110,65134,65157,65178,65198,65217,65235,65252,65268,65283  };

unsigned char FreqSelect,MusicSelect;

//以16分音符为一个时间单位，4分音符为4个时间单位
unsigned char Music[] = {
	13,4,
	13,4,
	20,4,
	20,4,
	22,4,
	22,4,
	20,4+4,
	18,4,
	18,4,
	17,4,
	17,4,
	15,4,
	15,4,
	13,4+4,
	0xFF
};

void main()
{
	Timer0_Init();
    while(1)
    {
		if(Music[MusicSelect] != 0xFF)
		{
			FreqSelect = Music[MusicSelect];
			MusicSelect++;
			Delay(SPEED*Music[MusicSelect]);
			MusicSelect++;
			//避免两个音连续，需要有抬手过程
			TR0 = 0;
			Delay(5);
			TR0 = 1;
		}
		else
		{
			TR0 = 0;
			while(1);//也可以设置循环播放
		}
    }
}


void Timer0_Routine() interrupt 1
{
	if(Music[MusicSelect] != 0)
	{
		TH0 = FreqTable[FreqSelect]/256;	//保证下一次中断的初始值不变
		TL0 = FreqTable[FreqSelect]%256;
		Buzzer = !Buzzer;
	}
}
```

### I2C总线

#### AT24C02

![image-20230404232050367](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304042320468.png)

- 引脚及其电路

> WP：不修改的话，不开启写保护

![image-20230404235414368](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304042354460.png)

- 内部结构框图

![image-20230405001553238](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304050015311.png)

#### 存储器的介绍

> 锁存器，触发器
>
> DRAM：用电容存储数据，动态扫描电路，避免漏电丢失数据，用于内存条，运存
>
> SRAM：速度更快，用于CPU的cache
>
> PROM：二极管被击穿，则短路，表示数据0（早期破坏单片机称为 烧录）

![image-20230404232542192](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304042325312.png)

![image-20230404235128778](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304042351863.png)

#### I2C总线介绍

> 一句话说明白：
>
> 总线默认为1，通信时发送数据0 总线为0，发送完毕自动回到1

![image-20230404232635762](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304042326864.png)

##### IIC电路规范

![image-20230405003146075](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304050031170.png)

##### IIC时序结构

![image-20230409190044522](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304091900603.png)

> SCL低电平时，可以改变数据，SCL高电平时，读取数据

![image-20230409190523807](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304091905891.png)

![image-20230409191739745](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304091917840.png)

> 应答可以算是 数据的第九位
>
> 应答标志：0表示应答

![image-20230409191937026](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304091919116.png)

##### IIC数据帧

![image-20230409192824716](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304091928800.png)



![image-20230409193142979](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304091931058.png)



> 复合收发格式

![image-20230409194720447](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304091947543.png)



![image-20230409193916523](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304091939629.png)

#### 程序代码

- main.c

```C
#include <REGX52.H>
#include "Delay.h"
#include "LCD1602.h"
#include "Key.h"
#include "AT24C02.h"

unsigned char Data;

void main()
{
	LCD_Init();
	LCD_ShowString(1,1,"hello");
	AT24CO2_WriteByte(1,123);
	Delay(5);  //延迟5ms
	Data = AT24C02_ReadByte(1);
	LCD_ShowNum(2,1,Data,3);
    while(1)
    {
        
    }
}
```

- I2C.c

```C
#include <REGX52.H>

sbit I2C_SCL = P2^1;
sbit I2C_SDA = P2^0;

/**
  * @brief I2C开始通信
  * @param 无
  * @retval 无
  */
void I2C_Start()
{
	//保证start之前，SDA,SCL都是高电平
	I2C_SDA = 1;
	I2C_SCL = 1;
	
	//start标志
	I2C_SDA = 0;
	I2C_SCL = 0;
}

/**
  * @brief I2C停止通信
  * @param 无
  * @retval 无
  */
void I2C_Stop()
{
	I2C_SDA = 0;
	I2C_SCL = 1;
	I2C_SDA = 1;
}

/**
  * @brief I2C发送一个字节
  * @param Byte 要发送的字节
  * @retval 无
  */

void I2C_SendByte(unsigned char Byte)
{
	unsigned char i;
	for(i = 0; i < 8;i++)
	{
		I2C_SDA = Byte & (0x80 >> i);
		I2C_SCL = 1;
		I2C_SCL = 0;	
	}
}

/**
  * @brief I2C接收一个字节
  * @param 无
  * @retval 接收到的字节
  */

unsigned char I2C_ReceiveByte()
{
	unsigned char i,Byte = 0x00;
	I2C_SDA = 1;
	
	for(i = 0; i < 8; i++)
	{
		I2C_SCL = 1;
		if(I2C_SDA){Byte |= (0x80>>i);}//读取的是1就置1，默认不处理为0
		I2C_SCL = 0;
	}
	return Byte;
}

/**
  * @brief I2C发送应答
* * @param	AckBit 应答位，0为应答，1为非应答
  * @retval 无
  */

void I2C_SendAck(unsigned char AckBit)
{
	I2C_SDA = AckBit;
	I2C_SCL = 1;
	I2C_SCL = 0;
}

/**
  * @brief I2C接收应答位
  * @param 无
  * @retval 接收的应答位
  */

unsigned char I2C_ReceiveAck()
{
	unsigned char AckBit;
	I2C_SDA = 1;
	I2C_SCL = 1;
	AckBit = I2C_SDA; //如果变0为接收应答
	I2C_SCL = 0;
	return AckBit;
}
```

- AT24C02.c

```C
#include <REGX52.H>
#include "I2C.h"

#define AT24C02_ADDRESS 0xA0
/**
  * @brief AT24C02写入一个字节
  * @param WordAddress 要写入的地址 Data 要写入的数据
  * @retval 无
  */
void AT24C02_WriteByte(unsigned char WordAddress,Data)
{
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS);
	I2C_ReceiveAck();
	I2C_SendByte(WordAddress);
	I2C_ReceiveAck();
	I2C_SendByte(Data);
	I2C_ReceiveAck();
	I2C_Stop();
}

/**
  * @brief AT24C02读取一个字节
  * @param WordAddress 要读出字节的地址
  * @retval 读出的数据
  */
unsigned char AT24C02_ReadByte(unsigned char WordAddress)
{
	unsigned char Data;
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS);
	I2C_ReceiveAck();
	I2C_SendByte(WordAddress);
	I2C_ReceiveAck();
	
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS | 0x01); //变为读地址
	I2C_ReceiveAck();
	Data = I2C_ReceiveByte();
	I2C_SendAck(1);
	I2C_Stop();
	
	return Data;
}
```

## DS18B20温度传感器

### 器件介绍

![image-20230424151725526](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304241517716.png)

![image-20230424154011543](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304241540647.png)

### 单总线

![image-20230424154522692](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304241545799.png)

### 时序结构

#### 初始化

![image-20230424155930952](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304241559029.png)

#### 发送一位bit

![image-20230424160011949](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304241600031.png)

#### DS18B20数据帧

![image-20230427160459570](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304271604752.png)

#### 温度存储

> 以补码形式存储

![](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202304271611153.png)

#### 程序代码

- OneWire.c

```C
//#include <REGX52.H>

//sbit OneWire_DQ = P3^7;

//unsigned char OneWire_Init()
//{
//	unsigned char i;
//	unsigned char AckBit;
//	OneWire_DQ = 1;
//	OneWire_DQ = 0;
//	
//	i = 227;while (--i);	//延时500us，至少480us
//	OneWire_DQ = 1;
//	i = 29;while (--i);	//延时70us
//	AckBit = OneWire_DQ;
//	i = 227;while (--i);	//延时500us
//	
//	return AckBit;
//}

//void OneWire_SendBit(unsigned char Bit)
//{
//	unsigned char i;
//	OneWire_DQ = 0;
//	i = 4;while (--i);	//延时10us
//	OneWire_DQ = Bit;
//	i = 24;while (--i);	//延时49us
//	OneWire_DQ = 1;
//}

//unsigned char OneWire_ReceiveBit()
//{
//	unsigned char i;
//	unsigned char Bit;
//	OneWire_DQ = 0;
//	i = 2;while (--i); //5us
//	OneWire_DQ = 1;
//	i = 2;while (--i); //5us
//	Bit = OneWire_DQ;
//	i = 24;while (--i);//延时49us
//	return Bit;
//}

//void OneWire_SendByte(unsigned char Byte)
//{
//	unsigned char i;
//	for(i=0;i<8;i++)
//	{
//		OneWire_SendBit(Byte&(0x01<<i));
//	}
//}

//unsigned char OneWire_ReceiveByte()
//{
//	unsigned char i;
//	unsigned char Byte = 0x00;
//	for(i=0;i<8;i++)
//	{
//		if(OneWire_ReceiveBit()){Byte|=(0x01<<i);}
//	}
//	return Byte;
//}
#include <REGX52.H>

//引脚定义
sbit OneWire_DQ=P3^7;

/**
  * @brief  单总线初始化
  * @param  无
  * @retval 从机响应位，0为响应，1为未响应
  */
unsigned char OneWire_Init(void)
{
	unsigned char i;
	unsigned char AckBit;
	OneWire_DQ=1;
	OneWire_DQ=0;
	i = 247;while (--i);		//Delay 500us
	OneWire_DQ=1;
	i = 32;while (--i);			//Delay 70us
	AckBit=OneWire_DQ;
	i = 247;while (--i);		//Delay 500us
	return AckBit;
}

/**
  * @brief  单总线发送一位
  * @param  Bit 要发送的位
  * @retval 无
  */
void OneWire_SendBit(unsigned char Bit)
{
	unsigned char i;
	OneWire_DQ=0;
	i = 4;while (--i);			//Delay 10us
	OneWire_DQ=Bit;
	i = 24;while (--i);			//Delay 50us
	OneWire_DQ=1;
}

/**
  * @brief  单总线接收一位
  * @param  无
  * @retval 读取的位
  */
unsigned char OneWire_ReceiveBit(void)
{
	unsigned char i;
	unsigned char Bit;
	OneWire_DQ=0;
	i = 2;while (--i);			//Delay 5us
	OneWire_DQ=1;
	i = 2;while (--i);			//Delay 5us
	Bit=OneWire_DQ;
	i = 24;while (--i);			//Delay 50us
	return Bit;
}

/**
  * @brief  单总线发送一个字节
  * @param  Byte 要发送的字节
  * @retval 无
  */
void OneWire_SendByte(unsigned char Byte)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		OneWire_SendBit(Byte&(0x01<<i));
	}
}

/**
  * @brief  单总线接收一个字节
  * @param  无
  * @retval 接收的一个字节
  */
unsigned char OneWire_ReceiveByte(void)
{
	unsigned char i;
	unsigned char Byte=0x00;
	for(i=0;i<8;i++)
	{
		if(OneWire_ReceiveBit()){Byte|=(0x01<<i);}
	}
	return Byte;
}

```

- DS18B20.c

```C
#include <REGX52.H>
#include "OneWire.h"

//DS18B20指令
#define DS18B20_SKIP_ROM			0xCC
#define DS18B20_CONVERT_T			0x44
#define DS18B20_READ_SCRATCHPAD 	0xBE

/**
  * @brief  DS18B20开始温度变换
  * @param  无
  * @retval 无
  */
void DS18B20_ConvertT(void)
{
	OneWire_Init();
	OneWire_SendByte(DS18B20_SKIP_ROM);
	OneWire_SendByte(DS18B20_CONVERT_T);
}

/**
  * @brief  DS18B20读取温度
  * @param  无
  * @retval 温度数值
  */
float DS18B20_ReadT(void)
{
	unsigned char TLSB,TMSB;
	int Temp;
	float T;
	OneWire_Init();
	OneWire_SendByte(DS18B20_SKIP_ROM);
	OneWire_SendByte(DS18B20_READ_SCRATCHPAD);
	TLSB=OneWire_ReceiveByte();
	TMSB=OneWire_ReceiveByte();
	Temp=(TMSB<<8)|TLSB;
	T=Temp/16.0;
	return T;
}

```

## LCD1602

### 简介

![image-20230504163735384](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041637485.png)

![image-20230504164310711](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041643834.png)

### 初始化

![image-20230503162903221](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305031629387.png)

### 时序

![image-20230504164406814](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041644897.png)

![image-20230504164419013](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041644089.png)

![image-20230504164429512](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041644575.png)

## 直流电机驱动PWM

### 简介

![image-20230504164800695](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041648777.png)

### 电机驱动电路

> 电机不能直连IO口
>
> 二极管作用：续流二极管

![image-20230504165414025](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041654112.png)

### PWM

> 占空比： 占 1 ，空 0

![image-20230504170506070](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041705148.png)

### 产生PWM的方法

![image-20230504173528488](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041735552.png)

## AD/DA

### 简介

![image-20230504175112030](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041751113.png)

### 硬件电路

> 虚短：Un和Up相等
>
> 虚断：Un的输入阻抗很大，电流不流入不流出

![image-20230504180321894](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041803965.png)

![image-20230504190533164](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305041905298.png)

- 原理

![image-20230505115747121](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051157300.png)

![image-20230505120301569](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051203702.png)

![image-20230505120854104](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051208253.png)

> 负反馈时，Un ≈ Up

![image-20230505120940474](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051209648.png)

> 不仅仅是短接，还可以串联电阻、电容

![image-20230505121048198](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051210301.png)

> 为了测量负载的工作电压，实在太小不好测量，可以放大方便测量

![image-20230505121240845](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051212948.png)

#### 四种运放电路

![image-20230505171302018](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051713097.png)

![image-20230505171323227](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051713305.png)

### DA原理

> 电阻网络中，电阻并联缩小一倍，多次并联后，总阻值为R

![image-20230505171106899](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051711967.png)

#### PWM型DA转换器

![image-20230505173129746](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051731828.png)

> 低通滤波器：去掉交流，留下直流

![image-20230505172508785](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051725857.png)

### AD原理

> 输入的量用DAC比较，二分法比较

![image-20230505173817455](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051738538.png)

### 性能指标

![image-20230505182228045](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051822127.png)

### XPT2046

#### 时序（SPI）

> CS：片选引脚
>
> MOSI :主设备输出，从设备输入
>
> MISO:主设备输入，从设备输出
>
> SPI：时钟上升沿输入，下降沿输出

![image-20230505182556356](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051825421.png)

> DIN输入的信息位

![image-20230505184659362](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051846426.png)

![image-20230505193157425](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051931497.png)

- 通过定义，描述地址

![image-20230505193405422](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305051934466.png)

## 红外遥控

### 简介

![image-20230508123837270](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305081238440.png)

### 接收电路

![image-20230508125246038](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305081252132.png)

### 发送和接收

![image-20230508125510265](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305081255351.png)

### NEC编码

![image-20230508131630319](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305081316838.png)

### 外部中断

> 低电平触发：连续触发
>
> 下降沿触发：触发一次

![image-20230508131141362](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305081311450.png)

### 外部中断寄存器

![image-20230508131354384](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305081313493.png)

## WIFI模块

### ESP8266

> wifi 和 蓝牙 都是 串口通讯

![image-20230508171310427](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305081713511.png)

### 引脚

> GPIO0：升级固件的适合置为低电平

![image-20230508171211777](https://typora-notes-codervv.oss-cn-shanghai.aliyuncs.com/img_for_typora/202305081712855.png)
